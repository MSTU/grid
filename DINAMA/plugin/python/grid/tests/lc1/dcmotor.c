/* Simulation code for dcmotor generated by the OpenModelica Compiler 1.9.0 beta4+dev (r16888). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_info_xml.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "dcmotor_functions.h"

#include "dcmotor_model.h"
#include "dcmotor_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif


#ifdef HPCOM
 #include <omp.h>
#endif

#ifdef _OPENMP
 #ifndef HPCOM
  #include <omp.h>
  #include <omp_perform_simulation.c>
 #else
  #include <perform_simulation.c>
 #endif
#else
 #ifndef HPCOM
  #include <perform_simulation.c>
  #define omp_get_max_threads() 1
 #else
  #include <perform_simulation.c>
 #endif
#endif


void setupDataStruc(DATA *data)
{
  ASSERT(data, "Error while initialize Data");
  data->modelData.modelName = "dcmotor";
  data->modelData.modelFilePrefix = "dcmotor";
  data->modelData.modelDir = "/home/lapshin/work/grid/DINAMA/plugin/python/grid/tests/lc1";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  #include "dcmotor_init.c"
  #include "dcmotor_info.c"
  #endif
  
  data->modelData.nStates = 3;
  data->modelData.nVariablesReal = 2*3+13;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 0;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 11;
  data->modelData.nParametersInteger = 1;
  data->modelData.nParametersBoolean = 2;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 0;
  data->modelData.nJacobians = 5;
  
  data->modelData.nAliasReal = 32;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 1;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 1;
  data->modelData.nMathEvents = 0;
  data->modelData.nInitEquations = 0;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 0;    /* data->modelData.nInitEquations + data->modelData.nInitAlgorithms */
  data->modelData.nExtObjs = 0;
  data->modelData.modelDataXml.fileName = "dcmotor_info.xml";
  data->modelData.modelDataXml.nFunctions = 0;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 44;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 0;
  data->modelData.nNonLinearSystems = 0;
  data->modelData.nStateSets = 0;
  data->modelData.nInlineVars = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}


/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
  INFO(LOG_DEBUG, "call external Object Constructors");
  INFO(LOG_DEBUG, "call external Object Constructors finished");
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
}

/* initial linear systems */
/* inline linear systems */
/* parameter linear systems */
/* model linear systems */
/* jacobians linear systems */

/* funtion initialize linear systems */
void initialLinearSystem(LINEAR_SYSTEM_DATA* linearSystemData)
{
  /* initial linear systems */
  /* inline linear systems */
  /* parameter linear systems */
  /* model linear systems */
  /* jacobians linear systems */
}

/* funtion initialize state sets */
void initializeStateSets(STATE_SET_DATA* statesetData, DATA *data)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_initSample(DATA *data)
{
  long i=0;

}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  INFO(LOG_INIT, "updating start-values");
  INDENT(LOG_INIT);
  RELEASE(LOG_INIT);
  
  return 0;
}

const char *initialResidualDescription[1] = {"empty"};

int initial_residual(DATA *data, double *initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  INFO(LOG_RES_INIT, "updating initial residuals");
  INDENT(LOG_RES_INIT);
  RELEASE(LOG_RES_INIT);
  restore_memory_state(mem_state);
  
  return 0;
}

/*
 equation index: 1
 type: SIMPLE_ASSIGN
 load._w = $_start(load.w)
 */
static void eqFunction_1(DATA *data)
{
  /* Dummy Line */
  $Pload$Pw = $P$ATTRIBUTE$Pload$Pw.start;
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 emf1._k = $_start(emf1.k)
 */
static void eqFunction_2(DATA *data)
{
  /* Dummy Line */
  $Pemf1$Pk = $P$ATTRIBUTE$Pemf1$Pk.start;
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 inductor1._i = $_start(inductor1.i)
 */
static void eqFunction_3(DATA *data)
{
  /* Dummy Line */
  $Pinductor1$Pi = $P$ATTRIBUTE$Pinductor1$Pi.start;
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 resistor1._T = resistor1.T_ref
 */
static void eqFunction_4(DATA *data)
{
  $Presistor1$PT = $Presistor1$PT_ref;
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 resistor1._R_actual = resistor1.R * (1.0 + resistor1.alpha * (resistor1.T - resistor1.T_ref))
 */
static void eqFunction_5(DATA *data)
{
  $Presistor1$PR_actual = ($Presistor1$PR * (1.0 + ($Presistor1$Palpha * ($Presistor1$PT - $Presistor1$PT_ref))));
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 der(load._phi) = load.w
 */
static void eqFunction_6(DATA *data)
{
  $P$DER$Pload$Pphi = $Pload$Pw;
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 emf1._internalSupport._tau = emf1.k * inductor1.i
 */
static void eqFunction_7(DATA *data)
{
  $Pemf1$PinternalSupport$Ptau = ($Pemf1$Pk * $Pinductor1$Pi);
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 load._a = DIVISION(emf1.internalSupport.tau, load.J, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_8(DATA *data)
{
  modelica_real tmp0;
  tmp0 = DIVISION($Pemf1$PinternalSupport$Ptau, $Pload$PJ, _OMC_LIT3);
  $Pload$Pa = tmp0;
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 der(load._w) = load.a
 */
static void eqFunction_9(DATA *data)
{
  $P$DER$Pload$Pw = $Pload$Pa;
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 emf1._v = emf1.k * load.w
 */
static void eqFunction_10(DATA *data)
{
  $Pemf1$Pv = ($Pemf1$Pk * $Pload$Pw);
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 resistor1._v = resistor1.R_actual * inductor1.i
 */
static void eqFunction_11(DATA *data)
{
  $Presistor1$Pv = ($Presistor1$PR_actual * $Pinductor1$Pi);
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 resistor1._LossPower = resistor1.v * inductor1.i
 */
static void eqFunction_12(DATA *data)
{
  $Presistor1$PLossPower = ($Presistor1$Pv * $Pinductor1$Pi);
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 signalVoltage1._v = step1.offset + (if time < step1.startTime then 0.0 else step1.height)
 */
static void eqFunction_13(DATA *data)
{
  modelica_boolean tmp1;
  RELATIONHYSTERESIS(tmp1, time, $Pstep1$PstartTime, 0, Less);
  $PsignalVoltage1$Pv = ($Pstep1$Poffset + (tmp1?0.0:$Pstep1$Pheight));
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 inductor1._p._v = (-resistor1.v) - signalVoltage1.v
 */
static void eqFunction_14(DATA *data)
{
  $Pinductor1$Pp$Pv = ((-$Presistor1$Pv) - $PsignalVoltage1$Pv);
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 inductor1._v = inductor1.p.v - emf1.v
 */
static void eqFunction_15(DATA *data)
{
  $Pinductor1$Pv = ($Pinductor1$Pp$Pv - $Pemf1$Pv);
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 der(inductor1._i) = DIVISION(inductor1.v, inductor1.L, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_16(DATA *data)
{
  modelica_real tmp2;
  tmp2 = DIVISION($Pinductor1$Pv, $Pinductor1$PL, _OMC_LIT2);
  $P$DER$Pinductor1$Pi = tmp2;
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 load._phi = $_start(load.phi)
 */
static void eqFunction_17(DATA *data)
{
  /* Dummy Line */
  $Pload$Pphi = $P$ATTRIBUTE$Pload$Pphi.start;
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 emf1._phi = load.phi - emf1.fixed.phi0
 */
static void eqFunction_18(DATA *data)
{
  $Pemf1$Pphi = ($Pload$Pphi - $Pemf1$Pfixed$Pphi0);
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 ground1._p._v = 0.0
 */
static void eqFunction_21(DATA *data)
{
  $Pground1$Pp$Pv = 0.0;
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 load._flange_b._tau = 0.0
 */
static void eqFunction_20(DATA *data)
{
  $Pload$Pflange_b$Ptau = 0.0;
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 ground1._p._i = 0.0
 */
static void eqFunction_19(DATA *data)
{
  $Pground1$Pp$Pi = 0.0;
}
const int useSymbolicInitialization = 1; /* true */
const int useHomotopy = 0; /* false */
int functionInitialEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  data->simulationInfo.discreteCall = 1;
  eqFunction_1(data);
  restore_memory_state(mem_state);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  eqFunction_3(data);
  restore_memory_state(mem_state);
  eqFunction_4(data);
  restore_memory_state(mem_state);
  eqFunction_5(data);
  restore_memory_state(mem_state);
  eqFunction_6(data);
  restore_memory_state(mem_state);
  eqFunction_7(data);
  restore_memory_state(mem_state);
  eqFunction_8(data);
  restore_memory_state(mem_state);
  eqFunction_9(data);
  restore_memory_state(mem_state);
  eqFunction_10(data);
  restore_memory_state(mem_state);
  eqFunction_11(data);
  restore_memory_state(mem_state);
  eqFunction_12(data);
  restore_memory_state(mem_state);
  eqFunction_13(data);
  restore_memory_state(mem_state);
  eqFunction_14(data);
  restore_memory_state(mem_state);
  eqFunction_15(data);
  restore_memory_state(mem_state);
  eqFunction_16(data);
  restore_memory_state(mem_state);
  eqFunction_17(data);
  restore_memory_state(mem_state);
  eqFunction_18(data);
  restore_memory_state(mem_state);
  eqFunction_21(data);
  restore_memory_state(mem_state);
  eqFunction_20(data);
  restore_memory_state(mem_state);
  eqFunction_19(data);
  restore_memory_state(mem_state);
  data->simulationInfo.discreteCall = 0;
  
  return 0;
}

int functionInlineEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 34
 type: SIMPLE_ASSIGN
 ground1._p._i = 0.0
 */
static void eqFunction_34(DATA *data)
{
  $Pground1$Pp$Pi = 0.0;
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 load._flange_b._tau = 0.0
 */
static void eqFunction_35(DATA *data)
{
  $Pload$Pflange_b$Ptau = 0.0;
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 ground1._p._v = 0.0
 */
static void eqFunction_36(DATA *data)
{
  $Pground1$Pp$Pv = 0.0;
}
/*
 equation index: 37
 type: SIMPLE_ASSIGN
 resistor1._T = resistor1.T_ref
 */
static void eqFunction_37(DATA *data)
{
  $Presistor1$PT = $Presistor1$PT_ref;
}
/*
 equation index: 38
 type: SIMPLE_ASSIGN
 resistor1._R_actual = resistor1.R * (1.0 + resistor1.alpha * (resistor1.T - resistor1.T_ref))
 */
static void eqFunction_38(DATA *data)
{
  $Presistor1$PR_actual = ($Presistor1$PR * (1.0 + ($Presistor1$Palpha * ($Presistor1$PT - $Presistor1$PT_ref))));
}
/*
 equation index: 39
 type: ALGORITHM
 
   assert(load.stateSelect >= StateSelect.never and load.stateSelect <= StateSelect.always, "Variable load.stateSelect out of [min, max] interval: load.stateSelect >= StateSelect.never and load.stateSelect <= StateSelect.always has value: " + String(load.stateSelect, "d"));
 */
static void eqFunction_39(DATA *data)
{
  modelica_boolean tmp0;
  modelica_boolean tmp1;
  modelica_string tmp2;
  modelica_string tmp3;
  static int tmp4 = 0;
  if(!tmp4)
  {
    tmp0 = GreaterEq((modelica_integer)$Pload$PstateSelect,1);
    tmp1 = LessEq((modelica_integer)$Pload$PstateSelect,5);
    if(!(tmp0 && tmp1))
    {
      tmp2 = modelica_integer_to_modelica_string_format((modelica_integer)$Pload$PstateSelect, "d");
      tmp3 = cat_modelica_string("Variable load.stateSelect out of [min, max] interval: load.stateSelect >= StateSelect.never and load.stateSelect <= StateSelect.always has value: ",tmp2);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Mechanics/Rotational.mo",1709,7,1711,61,1};
      omc_assert_warning(info, tmp3);
      tmp4 = 1;
    }
  }
}
/*
 equation index: 40
 type: ALGORITHM
 
   assert(load.J >= 0.0, "Variable load.J out of [min, max] interval: load.J >= 0.0 has value: " + String(load.J, "g"));
 */
static void eqFunction_40(DATA *data)
{
  modelica_boolean tmp5;
  modelica_string tmp6;
  modelica_string tmp7;
  static int tmp8 = 0;
  if(!tmp8)
  {
    tmp5 = GreaterEq($Pload$PJ,0.0);
    if(!tmp5)
    {
      tmp6 = modelica_real_to_modelica_string_format($Pload$PJ, "g");
      tmp7 = cat_modelica_string("Variable load.J out of [min, max] interval: load.J >= 0.0 has value: ",tmp6);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Mechanics/Rotational.mo",1708,7,1708,65,1};
      omc_assert_warning(info, tmp7);
      tmp8 = 1;
    }
  }
}
/*
 equation index: 41
 type: ALGORITHM
 
   assert(resistor1.T_ref >= 0.0, "Variable resistor1.T_ref out of [min, max] interval: resistor1.T_ref >= 0.0 has value: " + String(resistor1.T_ref, "g"));
 */
static void eqFunction_41(DATA *data)
{
  modelica_boolean tmp9;
  modelica_string tmp10;
  modelica_string tmp11;
  static int tmp12 = 0;
  if(!tmp12)
  {
    tmp9 = GreaterEq($Presistor1$PT_ref,0.0);
    if(!tmp9)
    {
      tmp10 = modelica_real_to_modelica_string_format($Presistor1$PT_ref, "g");
      tmp11 = cat_modelica_string("Variable resistor1.T_ref out of [min, max] interval: resistor1.T_ref >= 0.0 has value: ",tmp10);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",66,3,66,78,1};
      omc_assert_warning(info, tmp11);
      tmp12 = 1;
    }
  }
}
/*
 equation index: 42
 type: ALGORITHM
 
   assert(resistor1.T >= 0.0, "Variable resistor1.T out of [min, max] interval: resistor1.T >= 0.0 has value: " + String(resistor1.T, "g"));
 */
static void eqFunction_42(DATA *data)
{
  modelica_boolean tmp13;
  modelica_string tmp14;
  modelica_string tmp15;
  static int tmp16 = 0;
  if(!tmp16)
  {
    tmp13 = GreaterEq($Presistor1$PT,0.0);
    if(!tmp13)
    {
      tmp14 = modelica_real_to_modelica_string_format($Presistor1$PT, "g");
      tmp15 = cat_modelica_string("Variable resistor1.T out of [min, max] interval: resistor1.T >= 0.0 has value: ",tmp14);
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",312,5,313,99,1};
      omc_assert_warning(info, tmp15);
      tmp16 = 1;
    }
  }
}
int updateBoundParameters(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  eqFunction_34(data);
  restore_memory_state(mem_state);
  eqFunction_35(data);
  restore_memory_state(mem_state);
  eqFunction_36(data);
  restore_memory_state(mem_state);
  eqFunction_37(data);
  restore_memory_state(mem_state);
  eqFunction_38(data);
  restore_memory_state(mem_state);
  eqFunction_39(data);
  restore_memory_state(mem_state);
  eqFunction_40(data);
  restore_memory_state(mem_state);
  eqFunction_41(data);
  restore_memory_state(mem_state);
  eqFunction_42(data);
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 22
 type: SIMPLE_ASSIGN
 signalVoltage1._v = step1.offset + (if time < step1.startTime then 0.0 else step1.height)
 */
static void eqFunction_22(DATA *data)
{
  modelica_boolean tmp17;
  RELATIONHYSTERESIS(tmp17, time, $Pstep1$PstartTime, 0, Less);
  $PsignalVoltage1$Pv = ($Pstep1$Poffset + (tmp17?0.0:$Pstep1$Pheight));
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 resistor1._v = resistor1.R_actual * inductor1.i
 */
static void eqFunction_23(DATA *data)
{
  $Presistor1$Pv = ($Presistor1$PR_actual * $Pinductor1$Pi);
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 resistor1._LossPower = resistor1.v * inductor1.i
 */
static void eqFunction_24(DATA *data)
{
  $Presistor1$PLossPower = ($Presistor1$Pv * $Pinductor1$Pi);
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 inductor1._p._v = (-resistor1.v) - signalVoltage1.v
 */
static void eqFunction_25(DATA *data)
{
  $Pinductor1$Pp$Pv = ((-$Presistor1$Pv) - $PsignalVoltage1$Pv);
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 emf1._v = emf1.k * load.w
 */
static void eqFunction_26(DATA *data)
{
  $Pemf1$Pv = ($Pemf1$Pk * $Pload$Pw);
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 inductor1._v = inductor1.p.v - emf1.v
 */
static void eqFunction_27(DATA *data)
{
  $Pinductor1$Pv = ($Pinductor1$Pp$Pv - $Pemf1$Pv);
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 der(inductor1._i) = DIVISION(inductor1.v, inductor1.L, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_28(DATA *data)
{
  modelica_real tmp18;
  tmp18 = DIVISION($Pinductor1$Pv, $Pinductor1$PL, _OMC_LIT2);
  $P$DER$Pinductor1$Pi = tmp18;
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 emf1._internalSupport._tau = emf1.k * inductor1.i
 */
static void eqFunction_29(DATA *data)
{
  $Pemf1$PinternalSupport$Ptau = ($Pemf1$Pk * $Pinductor1$Pi);
}
/*
 equation index: 30
 type: SIMPLE_ASSIGN
 load._a = DIVISION(emf1.internalSupport.tau, load.J, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_30(DATA *data)
{
  modelica_real tmp19;
  tmp19 = DIVISION($Pemf1$PinternalSupport$Ptau, $Pload$PJ, _OMC_LIT3);
  $Pload$Pa = tmp19;
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 der(load._w) = load.a
 */
static void eqFunction_31(DATA *data)
{
  $P$DER$Pload$Pw = $Pload$Pa;
}
/*
 equation index: 32
 type: SIMPLE_ASSIGN
 der(load._phi) = load.w
 */
static void eqFunction_32(DATA *data)
{
  $P$DER$Pload$Pphi = $Pload$Pw;
}
/*
 equation index: 33
 type: SIMPLE_ASSIGN
 emf1._phi = load.phi - emf1.fixed.phi0
 */
static void eqFunction_33(DATA *data)
{
  $Pemf1$Pphi = ($Pload$Pphi - $Pemf1$Pfixed$Pphi0);
}
/*
 equation index: 43
 type: ALGORITHM
 
   assert(1.0 + resistor1.alpha * (resistor1.T - resistor1.T_ref) >= 0.000000000000001, "Temperature outside scope of model!");
 */
static void eqFunction_43(DATA *data)
{
  modelica_boolean tmp20;
  tmp20 = GreaterEq((1.0 + ($Presistor1$Palpha * ($Presistor1$PT - $Presistor1$PT_ref))),0.000000000000001);
  if(!tmp20)
  {
      FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",76,3,76,108,1};
      omc_assert(info, "Temperature outside scope of model!");
  }
}
int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_22(data);
  eqFunction_23(data);
  eqFunction_24(data);
  eqFunction_25(data);
  eqFunction_26(data);
  eqFunction_27(data);
  eqFunction_28(data);
  eqFunction_29(data);
  eqFunction_30(data);
  eqFunction_31(data);
  eqFunction_32(data);
  eqFunction_33(data);
  eqFunction_43(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(22);
  #endif
  eqFunction_22(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(22);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(23);
  #endif
  eqFunction_23(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(23);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(25);
  #endif
  eqFunction_25(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(25);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(26);
  #endif
  eqFunction_26(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(26);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(27);
  #endif
  eqFunction_27(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(27);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(28);
  #endif
  eqFunction_28(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(28);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(29);
  #endif
  eqFunction_29(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(29);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(30);
  #endif
  eqFunction_30(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(30);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(31);
  #endif
  eqFunction_31(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(31);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(32);
  #endif
  eqFunction_32(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(32);
  #endif
  restore_memory_state(mem_state);
}

void function_initMemoryState()
{
#ifdef _OPENMP
  push_memory_states(omp_get_max_threads());
  get_thread_index = omp_get_thread_num;
#else
  push_memory_states(1);
#endif
}

int functionODE(DATA *data)
{
#ifdef _OMC_MEASURE_TIME
  rt_tick(SIM_TIMER_FUNCTION_ODE);
#endif

  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();
  
  data->simulationInfo.discreteCall = 0;
  functionODE_system0(data);
  restore_memory_state(mem_state);
#ifdef _OMC_MEASURE_TIME
  rt_accumulate(SIM_TIMER_FUNCTION_ODE);
#endif

  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

static void functionAlg_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(24);
  #endif
  eqFunction_24(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(24);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(33);
  #endif
  eqFunction_33(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(33);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(43);
  #endif
  eqFunction_43(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(43);
  #endif
  restore_memory_state(mem_state);
}
/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  data->simulationInfo.discreteCall = 0;
  functionAlg_system0(data);
  return 0;
}

const char *zeroCrossingDescription[] =
{
  "time < step1.startTime", 
};

int function_ZeroCrossings(DATA *data, double *gout, double *t)
{
  state mem_state;
  modelica_boolean tmp2;
  
  mem_state = get_memory_state();
  tmp2 = LessZC(time,$Pstep1$PstartTime, data->simulationInfo.hysteresisEnabled[0]);
  ZEROCROSSING(0, (tmp2)?1:-1);
  restore_memory_state(mem_state);
  
  return 0;
}

const char *relationDescription[] =
{
  "time < step1.startTime", 
};

int function_updateRelations(DATA *data, int evalforZeroCross)
{
  state mem_state;
  modelica_boolean tmp3;
  
  mem_state = get_memory_state();
  if(evalforZeroCross)
  {
    tmp3 = LessZC(time,$Pstep1$PstartTime, data->simulationInfo.hysteresisEnabled[0]);
    data->simulationInfo.relations[0] = tmp3;
  }
  else
  {
    data->simulationInfo.relations[0] = (time < $Pstep1$PstartTime);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  DEBUG(LOG_EVENTS, "check for discrete changes");
  INDENT(LOG_EVENTS);
  RELEASE(LOG_EVENTS);
  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

/* initial mixed systems */
/* inline mixed systems */
/* parameter mixed systems */
/* model mixed systems */
/* jacobians mixed systems */

/* funtion initialize mixed systems */
void initialMixedSystem(MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* inline mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

int initialAnalyticJacobianG(void* inData)
{
  return 1;
}
int initialAnalyticJacobianA(void* inData)
{
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  
  int i;
  
  data->simulationInfo.analyticJacobians[index].sizeCols = 3;
  data->simulationInfo.analyticJacobians[index].sizeRows = 3;
  data->simulationInfo.analyticJacobians[index].seedVars = (modelica_real*) calloc(3,sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].resultVars = (modelica_real*) malloc(3*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].tmpVars = (modelica_real*) malloc(0*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex = (unsigned int*) malloc(3*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.index = (unsigned int*) malloc(4*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols = (unsigned int*) malloc(3*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.maxColors = 2;
  data->simulationInfo.analyticJacobians[index].jacobian = NULL;
  
  /* write column ptr of compressed sparse column*/
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pinductor1$Pi$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pload$Pphi$pDERA$indexdiff] = 0;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pload$Pw$pDERA$indexdiff] = 2;
  for(i=1;i<3;++i)
      data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i] += data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i-1];
  
  
  /* write index */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pinductor1$Pi$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $Pload$Pw$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pinductor1$Pi$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $Pinductor1$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pload$Pw$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $Pload$Pphi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$Pload$Pw$pDERA$indexdiff] - 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $Pinductor1$Pi$pDERA$indexdiffed;
  
  /* write color array */
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$Pinductor1$Pi$pDERA$indexdiff] = 1;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$Pload$Pphi$pDERA$indexdiff] = 1;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$Pload$Pw$pDERA$indexdiff] = 2;
  
  return 0;
}
int initialAnalyticJacobianB(void* inData)
{
  return 1;
}
int initialAnalyticJacobianC(void* inData)
{
  return 1;
}
int initialAnalyticJacobianD(void* inData)
{
  return 1;
}

int functionJacG_column(void* data)
{
  return 0;
}
int functionJacA_column(void* inData)
{
  state mem_state;
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  return 0;
}
int functionJacB_column(void* data)
{
  return 0;
}
int functionJacC_column(void* data)
{
  return 0;
}
int functionJacD_column(void* data)
{
  return 0;
}
int mayer(DATA* data, modelica_real* res){return -1;}
     int lagrange(DATA* data, modelica_real* res){return -1;}
const char *linear_model_frame =
  "model linear_dcmotor\n  parameter Integer n = 3; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 0; // top-level outputs \n"
  "  parameter Real x0[3] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[3,3] = [%s];\n"
  "  parameter Real B[3,0] = zeros(3,0);%s\n"
  "  parameter Real C[0,3] = zeros(0,3);%s\n"
  "  parameter Real D[0,0] = zeros(0,0);%s\n"
  "  Real x[3](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[0];\n"
  "\n  Real x_PloadPw = x[1];\n  Real x_PloadPphi = x[2];\n  Real x_Pinductor1Pi = x[3];\n      \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_dcmotor;\n"
;

#ifdef __cplusplus
}
#endif

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}

